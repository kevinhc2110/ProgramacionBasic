# Desarrollo Backend con Go

El desarrollo backend con Go es una de las áreas en las que el lenguaje brilla, gracias a su eficiencia, concurrencia y facilidad para manejar aplicaciones de red. Go es una excelente opción para construir servidores, APIs y sistemas distribuidos que requieren alto rendimiento.

## 16.1. Creación de APIs

Go facilita la creación de APIs RESTful con su paquete estándar net/http, aunque también se pueden usar frameworks como Gin o Echo para simplificar el manejo de rutas y middlewares.

```go
package main

import (
    "net/http"
    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()

    // Definir ruta GET
    r.GET("/api/v1/status", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "API corriendo correctamente",
        })
    })

    // Iniciar el servidor en el puerto 8080
    r.Run(":8080")
}

```

---

## 16.2. Manejo de Rutas

En Go, se pueden manejar rutas directamente con el paquete net/http, pero los frameworks como Gin y Echo permiten organizar el código de manera más modular.

- **Sin frameworks:**

  ```go
  http.HandleFunc("/ruta", handlerFunc)

  ```

- **Con Gin o Echo:** Permiten la creación de grupos de rutas, middlewares y más:

  ```go
  r := gin.Default()
  r.GET("/users", getUsers)
  r.POST("/users", createUser)

  ```

---

## 16.3. Autenticación y Autorización

La autenticación y autorización son aspectos críticos para el desarrollo backend. En Go, estas funcionalidades suelen implementarse con middlewares y bibliotecas de terceros:

- **JWT (JSON Web Tokens):** Para autenticar usuarios de manera segura mediante tokens. Librerías como github.com/golang-jwt/jwt o go-chi/jwtauth facilitan el uso de JWT.

- **OAuth2:** Es posible integrar autenticación mediante OAuth2 usando golang.org/x/oauth2 para servicios de terceros como Google, GitHub, etc.

```go
import (
    "net/http"
    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt"
)

var jwtKey = []byte("mi_clave_secreta")

// Middleware de autenticación JWT
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        tokenString := c.GetHeader("Authorization")
        if tokenString == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "No autorizado"})
            c.Abort()
            return
        }
        // Validar el token
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            return jwtKey, nil
        })
        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Token inválido"})
            c.Abort()
            return
        }
        c.Next()
    }
}

```

---

## 16.4. Gestión de Bases de Datos

Go ofrece soporte tanto para bases de datos relacionales (SQL) como NoSQL, y los ORMs como GORM facilitan el acceso a datos.

```go
import (
    "github.com/jinzhu/gorm"
    _ "github.com/jinzhu/gorm/dialects/postgres"
)

func main() {
    db, err := gorm.Open("postgres", "host=localhost user=miusuario dbname=mibasedatos sslmode=disable")
    if err != nil {
        panic("Error al conectar a la base de datos")
    }
    defer db.Close()

    // Migrar el esquema
    db.AutoMigrate(&Usuario{})
}

type Usuario struct {
    ID        uint   `gorm:"primary_key"`
    Nombre    string
    Email     string `gorm:"type:varchar(100);unique_index"`
    Contraseña string
}

```

---

## 16.5. Concurrencia y Paralelismo

Go permite manejar múltiples solicitudes de manera eficiente usando goroutines. Esto es particularmente útil en servidores backend donde se reciben muchas solicitudes simultáneas.

```go
func handleRequest(w http.ResponseWriter, r *http.Request) {
    go procesarSolicitud(r) // Ejecutar en una goroutine
    fmt.Fprintf(w, "Solicitud recibida")
}

func procesarSolicitud(r *http.Request) {
    // Procesar solicitud de manera concurrente
}

```

---

## 16.6. Microservicios

La arquitectura de microservicios divide una aplicación en servicios pequeños, independientes y desplegables de manera autónoma. Go es una excelente elección para construir microservicios debido a su eficiencia, soporte de concurrencia y facilidad para crear servicios de alto rendimiento.

- **16.6.1. Ventajas de los Microservicios**

  - Escalabilidad: Cada microservicio puede escalarse de forma independiente según la demanda.
  - Mantenibilidad: Código más modular y fácil de mantener.
  - Despliegue Independiente: Permite actualizaciones y despliegues sin afectar todo el sistema.
  - Tecnologías Heterogéneas: Diferentes microservicios pueden estar escritos en distintos lenguajes o usar diferentes tecnologías.

- **16.6.2. Diseño de Microservicios en Go**

  - Comunicación entre Microservicios

    - RESTful APIs: Uso de HTTP para la comunicación entre servicios.
    - gRPC: Comunicación eficiente basada en Protocol Buffers, ideal para servicios de alto rendimiento.
    - Mensajería Asíncrona: Utilización de sistemas como NATS, RabbitMQ o Kafka para la comunicación basada en eventos.

  - Frameworks y Herramientas para Microservicios en Go

    - Go Kit: Un framework robusto para construir microservicios en Go, que ofrece soporte para transporte, middlewares, logging, circuit breakers, entre otros.

      ```go
      import (
      kitlog "github.com/go-kit/kit/log"
      "github.com/go-kit/kit/endpoint"
      "github.com/go-kit/kit/transport/http"
      )

      func main() {
          logger := kitlog.NewLogfmtLogger(os.Stderr)
          svc := MyService{}

          endpoint := MakeMyEndpoint(svc)
          handler := http.NewServer(
              endpoint,
              decodeRequest,
              encodeResponse,
          )

          http.Handle("/myservice", handler)
          logger.Log("msg", "Servidor iniciado en :8080")
          logger.Log("err", http.ListenAndServe(":8080", nil))
      }

      ```

    - Micro: Un ecosistema completo para desarrollar microservicios, que incluye gestión de servicios, balanceo de carga, descubrimiento de servicios y más.

      ```go
      import (
          "github.com/micro/go-micro/v2"
          "github.com/micro/go-micro/v2/service/logger"
      )

      func main() {
          // Crear nuevo servicio
          service := micro.NewService(
              micro.Name("mi.microservicio"),
              micro.Version("1.0.0"),
          )

          // Inicializar el servicio
          service.Init()

          // Registrar el handler
          if err := RegisterMiServicioHandler(service.Server(), newHandler()); err != nil {
              logger.Fatal(err)
          }

          // Ejecutar el servicio
          if err := service.Run(); err != nil {
              logger.Fatal(err)
          }
      }

      ```

    - Fiber: Aunque principalmente es un framework web, Fiber puede ser utilizado para construir microservicios ligeros y de alto rendimiento.

  - Gestión de Configuración y Descubrimiento de Servicios

    - Consul: Para el descubrimiento y configuración de servicios.

      ```go
      import (
          "github.com/hashicorp/consul/api"
      )

      func registerService() {
          config := api.DefaultConfig()
          client, err := api.NewClient(config)
          if err != nil {
              panic(err)
          }

          agent := client.Agent()
          registration := new(api.AgentServiceRegistration)
          registration.ID = "mi-servicio-1"
          registration.Name = "mi-servicio"
          registration.Address = "127.0.0.1"
          registration.Port = 8080

          agent.ServiceRegister(registration)
      }

      ```

    - etcd: Un almacén de claves-valor distribuido que puede ser utilizado para la configuración y descubrimiento de servicios.

- **16.6.3. Ejemplo de Microservicio Básico con Gin y gRPC**

  A continuación, se muestra un ejemplo sencillo de cómo crear dos microservicios en Go que se comunican usando gRPC.

  - Microservicio 1: Servicio de Usuario

    - Definición de Protobuf (user.proto):

      ```proto
      syntax = "proto3";

      package user;

      service UserService {
          rpc GetUser (GetUserRequest) returns (GetUserResponse);
      }

      message GetUserRequest {
          int32 id = 1;
      }

      message GetUserResponse {
          int32 id = 1;
          string nombre = 2;
          string email = 3;
      }

      ```

- Comando para generar el código Go:

```sh
protoc --go_out=. --go-grpc_out=. user.proto

```

- Implementación del Servicio:

  ```go
  package main

  import (
      "context"
      "net"
      "log"
      "github.com/tu_usuario/tu_proyecto/user"
      "google.golang.org/grpc"
  )

  type server struct {
      user.UnimplementedUserServiceServer
  }

  func (s *server) GetUser(ctx context.Context, req *user.GetUserRequest) (*user.GetUserResponse, error) {
      // Simulación de obtención de usuario
      return &user.GetUserResponse{
          Id:     req.Id,
          Nombre: "Juan Pérez",
          Email:  "juan.perez@example.com",
      }, nil
  }

  func main() {
      lis, err := net.Listen("tcp", ":50051")
      if err != nil {
          log.Fatalf("Failed to listen: %v", err)
      }

      s := grpc.NewServer()
      user.RegisterUserServiceServer(s, &server{})
      log.Println("Servicio de Usuario iniciado en :50051")
      if err := s.Serve(lis); err != nil {
          log.Fatalf("Failed to serve: %v", err)
      }
  }

  ```

- Microservicio 2: Servicio Principal que Consume el Servicio de Usuario

  ```go
  package main

  import (
      "context"
      "log"
      "net/http"

      "github.com/gin-gonic/gin"
      "google.golang.org/grpc"
      "github.com/tu_usuario/tu_proyecto/user"
  )

  func main() {
      // Conectar al servicio de usuario
      conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
      if err != nil {
          log.Fatalf("No se pudo conectar al servicio de usuario: %v", err)
      }
      defer conn.Close()
      client := user.NewUserServiceClient(conn)

      r := gin.Default()

      r.GET("/api/v1/users/:id", func(c *gin.Context) {
          id := c.Param("id")
          req := &user.GetUserRequest{Id: 1} // Aquí se debería convertir el id a int32

          res, err := client.GetUser(context.Background(), req)
          if err != nil {
              c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
              return
          }

          c.JSON(http.StatusOK, res)
      })

      r.Run(":8080")
  }

  ```

---

## 16.6.4. Despliegue y Orquestación

Para gestionar y desplegar microservicios en producción, es común utilizar herramientas de orquestación como Kubernetes. Kubernetes facilita la gestión de contenedores, el balanceo de carga, el escalado automático y la resiliencia de los servicios.

- Definición de un Deployment (user-deployment.yaml):

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
        - name: user-service
          image: tu_usuario/user-service:latest
          ports:
            - containerPort: 50051
```

- Definición de un Service (user-service.yaml):

```yaml
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
    - protocol: TCP
      port: 50051
      targetPort: 50051
  type: ClusterIP
```

- Comandos para aplicar la configuración:

```sh
kubectl apply -f user-deployment.yaml
kubectl apply -f user-service.yaml

```
