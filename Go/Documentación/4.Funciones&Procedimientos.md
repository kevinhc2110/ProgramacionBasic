# 4. Funciones y Procedimientos en Go

## 4.1. Definición de Funciones

- **Definición de una función:**

  Se utiliza la palabra clave func, seguida del nombre de la función, parámetros y tipo de retorno.

  ```go
  func nombreFuncion(param1 tipo1, param2 tipo2) tipoRetorno {
      // Cuerpo de la función
  }

  ```

- **Parámetros:**

  Los parámetros se definen entre paréntesis y pueden ser múltiples.

  ```go
  func suma(a int, b int) int {
      return a + b
  }

  ```

- **Tipos de retorno:**

  Una función puede retornar uno o varios valores.

  ```go
  func operaciones(a int, b int) (int, int) {
      suma := a + b
      resta := a - b
      return suma, resta
  }

  ```

- **Valores por defecto:**

  Go no soporta valores por defecto para parámetros. Todos los argumentos deben ser proporcionados al llamar a la función.

---

## 4.2. Ámbito de Funciones

- **Alcance local y global:**

  - Local: Las variables declaradas dentro de una función solo son accesibles dentro de esa función.
  - Global: Las variables declaradas fuera de una función son accesibles en cualquier parte del archivo (y en otros archivos si se exportan).

    ```go
    var globalVar = 10 // Variable global

    func ejemplo() {
        var localVar = 5 // Variable local
        fmt.Println(globalVar) // Acceso a variable global
    }

    ```

- **Variables estáticas:**

  Go no tiene variables estáticas en el sentido tradicional de C/C++. Sin embargo, puedes usar variables globales para mantener el estado entre llamadas a funciones.

---

## 4.3. Valor y Referencia

- **Paso por valor:**

  En Go, los parámetros se pasan a las funciones por valor, lo que significa que se pasa una copia del valor. Los cambios en el parámetro dentro de la función no afectan al valor original fuera de la función.

  ```go
  func incrementar(valor int) {
      valor++
  }

  func main() {
      num := 10
      incrementar(num)
      fmt.Println(num) // Output: 10, el valor original no cambia
  }

  ```

- **Paso por referencia usando punteros:**

  Para modificar el valor original dentro de una función, se puede pasar un puntero al valor en lugar del valor en sí. Esto se hace usando el operador & para obtener la dirección de una variable y el operador \* para desreferenciar el puntero.

  ```go
  func incrementar(valor *int) {
      *valor++
  }

  func main() {
      num := 10
      incrementar(&num)
      fmt.Println(num) // Output: 11, el valor original cambia
  }

  ```

---

## 4.4. Recursividad

Una función es recursiva si se llama a sí misma. Debe tener una condición de parada para evitar una llamada infinita.

```go
func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}

```

## 4.5. Sobrecarga de Funciones

Go no soporta sobrecarga de funciones (es decir, múltiples funciones con el mismo nombre pero diferentes parámetros). Debes usar nombres de funciones diferentes.

```go
func suma(a int, b int) int {
    return a + b
}

func sumaFloat(a float64, b float64) float64 {
    return a + b
}

```

---

## 4.6. Funciones Anónimas (Lambda)

- **Funciones anónimas:**

  Las funciones anónimas, también conocidas como lambdas, son funciones sin nombre. Se utilizan para definir funciones inline.

  ```go
  func main() {
      suma := func(a, b int) int {
          return a + b
      }
      fmt.Println(suma(3, 4)) // Output: 7
  }

  ```

- **Closures:**

  Un closure es una función anónima que captura y puede modificar variables de su entorno.

  ```go
  func contador() func() int {
      i := 0
      return func() int {
          i++
          return i
      }
  }

  func main() {
      c := contador()
      fmt.Println(c()) // Output: 1
      fmt.Println(c()) // Output: 2
  }

  ```

---

## 4.7. Callbacks

Un callback es una función que se pasa como argumento a otra función y se ejecuta dentro de esa función.

```go
// procesarDatos toma una lista de enteros y una función de callback.
// La función de callback se aplica a cada elemento de la lista.
func procesarDatos(datos []int, callback func(int)) {
    // Itera sobre cada elemento en la lista de datos
    for _, dato := range datos {
        // Llama a la función de callback con el elemento actual
        callback(dato)
    }
}

func main() {
    // Define una lista de enteros
    datos := []int{1, 2, 3, 4, 5}

    // Llama a procesarDatos con la lista y una función anónima como callback
    procesarDatos(datos, func(d int) {
        // La función de callback imprime cada dato precedido de "Dato:"
        fmt.Println("Dato:", d)
    })
}


```

---

## 4.8. Funciones con defer

La palabra clave defer se usa para posponer la ejecución de una función hasta que la función que la contiene termine de ejecutarse. Es útil para realizar tareas de limpieza, como cerrar archivos o liberar recursos.

```go
func abrirArchivo(nombre string) (*os.File, error) {
    archivo, err := os.Open(nombre)
    if err != nil {
        return nil, err
    }
    // `defer` garantiza que el archivo se cerrará al final de la función
    defer archivo.Close()
    return archivo, nil
}

func main() {
    archivo, err := abrirArchivo("ejemplo.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    // Procesar el archivo
}

```

---

## 4.9. Funciones como Parámetros

En Go, puedes pasar funciones como parámetros a otras funciones, lo que permite una gran flexibilidad y reutilización del código.

```go
// aplicarOperacion toma dos enteros y una función de operación, y aplica la función a los dos enteros.
func aplicarOperacion(a int, b int, operacion func(int, int) int) int {
    return operacion(a, b) // Llama a la función operacion con a y b como argumentos y devuelve el resultado
}

// suma toma dos enteros y devuelve su suma.
func suma(x int, y int) int {
    return x + y // Devuelve la suma de x e y
}

// resta toma dos enteros y devuelve su diferencia.
func resta(x int, y int) int {
    return x - y // Devuelve la resta de x e y
}

func main() {
    // Llama a aplicarOperacion con 5, 3, y la función suma. Almacena el resultado en resultadoSuma.
    resultadoSuma := aplicarOperacion(5, 3, suma)
    fmt.Println("Resultado de la suma:", resultadoSuma) // Imprime "Resultado de la suma: 8"

    // Llama a aplicarOperacion con 5, 3, y la función resta. Almacena el resultado en resultadoResta.
    resultadoResta := aplicarOperacion(5, 3, resta)
    fmt.Println("Resultado de la resta:", resultadoResta) // Imprime "Resultado de la resta: 2"
}

```

---

## 4.10. Funciones de Orden Superior

Las funciones de orden superior son aquellas que pueden recibir otras funciones como argumentos o devolver funciones como resultado.

```go
// operar toma dos enteros y una función de operación, y aplica la función a los dos enteros.
func operar(a int, b int, operacion func(int, int) int) int {
    return operacion(a, b) // Llama a la función operacion con a y b como argumentos y devuelve el resultado
}

func main() {
    // Define una función anónima que realiza la suma de dos enteros.
    suma := func(x int, y int) int {
        return x + y // Devuelve la suma de x e y
    }

    // Llama a operar con 5, 3, y la función suma. Almacena el resultado en resultado.
    resultado := operar(5, 3, suma)

    // Imprime el resultado de la operación (en este caso, la suma).
    fmt.Println(resultado) // Output: 8
}

```
