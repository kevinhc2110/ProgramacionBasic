# 1. Sintaxis y Variables en Go

## 1.1. Sintaxis B√°sica

Go es un lenguaje fuertemente tipado, dise√±ado para ser eficiente y f√°cil de leer. La estructura b√°sica de un programa en Go incluye **paquetes**, **funciones**, y **declaraciones**.

### Estructura del Lenguaje

- **Paquetes:** Todo programa en Go comienza con la declaraci√≥n de un paquete:

  ```go
  package main
  ```

- **Importaciones:** Para incluir bibliotecas est√°ndar o de terceros:

  ```go
  import "fmt"
  ```

- **Funciones:** La funci√≥n principal es `main()`, que es el punto de entrada del programa:

  ```go
  func main() {
      fmt.Println("¬°Hola, Go!")
  }
  ```

### Palabras Clave

Algunas de las palabras clave importantes en Go son:

- `var`, `const`: Para declarar variables y constantes.
- `func`: Para definir funciones.
- `if`, `else`, `for`, `switch`: Estructuras de control.
- `go`, `defer`, `return`: Para control de concurrencia y manejo de funciones.

### Operadores

Go incluye varios tipos de operadores:

- **Aritm√©ticos:** `+`, `-`, `*`, `/`, `%`
- **Comparaci√≥n:** `==`, `!=`, `<`, `>`, `<=`, `>=`
- **L√≥gicos:** `&&`, `||`, `!`
- **Bit a bit:** `&`, `|`, `^`, `&^`, `<<`, `>>`

### Terminadores

En Go, cada sentencia termina con una nueva l√≠nea o un punto y coma impl√≠cito, aunque el uso de punto y coma expl√≠cito es raro.

---

## 1.2. Declaraci√≥n de Variables

En Go, las variables pueden declararse de forma expl√≠cita con la palabra clave `var` o de manera impl√≠cita con el operador `:=`, que permite la inferencia de tipo.

### Tipos de Variables

Go es un lenguaje de tipado est√°tico, lo que significa que el tipo de una variable se debe definir en el momento de la declaraci√≥n o inferirlo.

- #### Declaraci√≥n expl√≠cita

  ```go
  var x int = 10
  var name string = "KevinDev"
  ```

- #### Declaraci√≥n impl√≠cita (inferencia de tipo)

  ```go
  y := 20        // int
  name2 := "GoLang"  // string
  ```

### Tipos de Datos B√°sicos

- `int`: Enteros (8, 16, 32, o 64 bits).
- `float32`, `float64`: N√∫meros con punto flotante.
- `string`: Cadenas de texto.
- `bool`: Booleanos (`true`, `false`).
- `rune`: Caracteres Unicode (alias de `int32`).

  ```go
  var num int = 42
  var decimal float64 = 3.14
  var flag bool = true
  var character rune = 'A'
  ```

### Mutabilidad

Las variables declaradas con `var` o `:=` son mutables, lo que significa que su valor puede cambiar.

```go
var x int = 5
x = 10 // Mutabilidad

```

---

## 1.3. √Åmbito de las Variables

El √°mbito o alcance de una variable define su visibilidad y duraci√≥n dentro del programa.

### Alcance Global

Las variables declaradas fuera de cualquier funci√≥n tienen alcance global y pueden ser accedidas desde cualquier parte del paquete.

```go
var globalVar = "Visible en todo el paquete"

func ejemplo() {
    fmt.Println(globalVar) // Acceso permitido
}

```

### Alcance Local

Las variables declaradas dentro de una funci√≥n tienen alcance local y solo pueden ser utilizadas dentro de esa funci√≥n.

```go
func ejemplo() {
    var localVar = "Solo visible aqu√≠"
    fmt.Println(localVar)
}
```

### Reglas de Visibilidad

- **√Åmbito del paquete:** Variables declaradas con la primera letra may√∫scula son exportables y accesibles fuera del paquete.
- **√Åmbito de funci√≥n:** Variables declaradas dentro de funciones o bloques solo son visibles dentro de ese contexto.

### Contexto de ejecuci√≥n

Go organiza las variables por el contexto en el que se ejecutan. Dependiendo del lugar donde se declaran, pueden ser visibles o no.

---

## 1.4. Conversi√≥n de Tipos

En Go, la conversi√≥n de tipos no es impl√≠cita, por lo que debe hacerse expl√≠citamente usando la sintaxis de typecasting.

### Conversi√≥n Expl√≠cita

```go
var entero int = 42
var decimal float64 = float64(entero) // Conversi√≥n expl√≠cita de int a float64
fmt.Println(decimal)

```

### Conversi√≥n Impl√≠cita

Go no admite conversiones impl√≠citas entre tipos. Si intentas sumar un entero y un flotante sin convertir expl√≠citamente uno de ellos, obtendr√°s un error.

```go
var x int = 5
var y float64 = 2.5
// fmt.Println(x + y) // Error, tipos incompatibles
fmt.Println(float64(x) + y) // Correcto

```

---

## 1.5. Constantes

Las constantes en Go se definen con la palabra clave const. A diferencia de las variables, las constantes no pueden cambiar su valor despu√©s de ser declaradas.

```go
const PI = 3.1416
const Greeting = "Hello, Go"

```

### Uso de Constantes

Las constantes se usan cuando un valor no debe ser modificado durante la ejecuci√≥n del programa. No se puede utilizar `:=` para definir constantes.

```go
const MaxConnections = 100
const Username = "admin"

```

### Diferencias con las Variables

- Las constantes no permiten reasignaci√≥n, mientras que las variables pueden cambiar su valor.
- Las constantes pueden ser usadas en expresiones constantes, donde el valor es conocido en tiempo de compilaci√≥n.

### Constantes Especiales: Iota

Es ideal para definir secuencias de valores relacionados, como d√≠as de la semana, meses del a√±o, estados de un proceso, etc.

```go
const (
    Monday = iota
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)
```

---

## 1.6. Caracteres de Escape

En Go, los caracteres de escape se utilizan dentro de las cadenas para incluir s√≠mbolos que de otra forma no se podr√≠an representar directamente o que tienen un significado especial. A continuaci√≥n se detallan los m√°s importantes:

- `\n`: Nueva l√≠nea.
- `\t`: Tabulador horizontal.
- `\v`: Tabulador vertical.
- `\\`: Barra invertida literal.
- `\"`: Comilla doble literal.
- `\'`: Comilla simple literal.
- `\r`: Retorno de carro.
- `\f`: Salto de p√°gina.
- `\b`: Retroceso.
- `\x00`: Car√°cter nulo (representaci√≥n hexadecimal).
- `\a`: Alerta (sonido).
- `\x0A`: Representaci√≥n hexadecimal de un byte (por ejemplo, 'A' es \x41).
- `\u20AC`: Representaci√≥n Unicode de 4 d√≠gitos hexadecimal (por ejemplo, el s√≠mbolo del euro ‚Ç¨ es \u20AC).
- `\U0001F497`: Representaci√≥n Unicode de 8 d√≠gitos hexadecimal (emoji de coraz√≥n ‚ù§Ô∏è).
- `\U0001F60A`: Representaci√≥n Unicode de longitud variable (emoji de sonrisa üòä).

```go
package main

import "fmt"

func main() {
    fmt.Println("Hola\nMundo")  // Nueva l√≠nea
    fmt.Println("Precio:\t$100") // Tabulador
    fmt.Println("Simbolo Euro: \u20AC") // Unicode
    fmt.Println("Emoji Coraz√≥n: \U0001F497") // Emoji
}

```

---

## 1.7. Argumentos de L√≠nea de Comandos

En Go, los argumentos de la l√≠nea de comandos se pueden acceder mediante el paquete est√°ndar os. Estos argumentos incluyen el nombre del programa y cualquier argumento adicional que se pase al ejecutar el programa desde la terminal.

### Acceso a los Argumentos

Los argumentos se encuentran en el slice os.Args, donde el primer elemento (os.Args[0]) es siempre el nombre del programa, y los elementos siguientes son los argumentos que se pasaron al programa.

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // Imprimir todos los argumentos de la l√≠nea de comandos
    fmt.Println(os.Args)

    // Acceder al primer argumento pasado (si existe)
    if len(os.Args) > 1 {
        fmt.Println("Argumento 1:", os.Args[1])
    } else {
        fmt.Println("No se pasaron argumentos.")
    }
}

```

### Ejecuci√≥n con Argumentos

Si ejecutas el programa anterior desde la terminal con el siguiente comando:

```bash
go run main.go argumento1 argumento2

```

La salida ser√°:

```csharp
[main.go argumento1 argumento2]
Argumento 1: argumento1

```

---

## 1.8. CLI en Go

CLI son las siglas de Command Line Interface, que en espa√±ol significa Interfaz de L√≠nea de Comandos. Es una forma de interactuar con un sistema operativo o una aplicaci√≥n escribiendo comandos de texto en una terminal.

Crear una CLI (Command-Line Interface) en Go es una tarea com√∫n y sencilla de implementar gracias a las capacidades nativas del lenguaje y a diversas bibliotecas que facilitan el desarrollo de aplicaciones CLI. Una de las bibliotecas m√°s populares para crear CLI en Go es Cobra.

### Opci√≥n 1: CLI sencilla sin bibliotecas

Primero, te muestro c√≥mo crear una CLI b√°sica en Go sin necesidad de usar ninguna biblioteca externa.

```go
package main

import (
 "flag"
 "fmt"
)

func main() {
 // Definir los flags (opciones de la CLI)
 name := flag.String("name", "Mundo", "Especifica el nombre a saludar")
 age := flag.Int("age", 0, "Especifica la edad")

 // Parsear los flags
 flag.Parse()

 // Usar los valores de los flags
 fmt.Printf("Hola, %s! Tienes %d a√±os.\n", *name, *age)
}

```

- **`flag.String`**: Define un `flag` de tipo `string` (en este caso, --name).
- **`flag.Int`**: Define un `flag` de tipo `int` (--age).
- **`flag.Parse()`**: Esta funci√≥n es la encargada de leer los argumentos pasados desde la l√≠nea de comandos.
- **Uso**: Cuando ejecutas el programa desde la terminal, puedes pasarle opciones:

  ```bash
  go run main.go --name=Juan --age=30

  ```

### Opci√≥n 2: CLI con Cobra

Si necesitas una CLI m√°s avanzada con subcomandos y mayor flexibilidad, Cobra es una excelente opci√≥n. Cobra es ampliamente utilizada, incluyendo en la CLI de Kubernetes.

- **Instala la biblioteca Cobra:**

  ```bash
  go get -u github.com/spf13/cobra@latest

  ```

- **Desarrollo de CLI:**

  ```go
  package main

  import (
  "fmt"
  "github.com/spf13/cobra"
  "os"
  )

  func main() {
  // Crear el comando ra√≠z
  var rootCmd = &cobra.Command{
    Use:   "greet",
    Short: "Greet es una CLI de ejemplo",
    Long:  `Una aplicaci√≥n CLI en Go creada con Cobra para saludar a las personas.`,
  }

  // Subcomando "hello"
  var helloCmd = &cobra.Command{
    Use:   "hello",
    Short: "Saludar a alguien",
    Run: func(cmd *cobra.Command, args []string) {
    if len(args) > 0 {
      fmt.Printf("Hola, %s!\n", args[0])
    } else {
      fmt.Println("Hola!")
    }
    },
  }

  // Subcomando "goodbye"
  var goodbyeCmd = &cobra.Command{
    Use:   "goodbye",
    Short: "Despedirse de alguien",
    Run: func(cmd *cobra.Command, args []string) {
    if len(args) > 0 {
      fmt.Printf("Adi√≥s, %s!\n", args[0])
    } else {
      fmt.Println("Adi√≥s!")
    }
    },
  }

  // Agregar los subcomandos al comando ra√≠z
  rootCmd.AddCommand(helloCmd)
  rootCmd.AddCommand(goodbyeCmd)

  // Ejecutar la CLI
  if err := rootCmd.Execute(); err != nil {
    fmt.Println(err)
    os.Exit(1)
  }
  }

  ```

  - **`rootCmd`**: Es el comando ra√≠z de la CLI, que en este caso es greet.
  - **Subcomandos**: Definimos dos subcomandos:
  - **hello**: Para saludar.
  - **goodbye**: Para despedirse.
  - **`AddCommand`**: A√±adimos los subcomandos al comando ra√≠z con `rootCmd.AddCommand(helloCmd)` y `rootCmd.AddCommand(goodbyeCmd)`.
  - **Uso**: Puedes ejecutar la CLI y usar los subcomandos

    ```bash
    go run main.go hello Juan
    # Salida: Hola, Juan!

    go run main.go goodbye Maria
    # Salida: Adi√≥s, Maria!

    ```

---

## 1.9. Comandos B√°sicos Go

- `go run`: Compila y ejecuta el programa.
- `go build`: Compila el c√≥digo fuente y genera un binario.
- `./miPrograma`: Ejecuta el binario generado por go build.
- `go install`: Compila y guarda el binario en el directorio de instalaci√≥n de Go.
- `go fmt`: Formatea el c√≥digo seg√∫n el estilo oficial.
- `go vet`: Realiza un an√°lisis est√°tico en busca de errores comunes.
- `go test`: Ejecuta pruebas unitarias.
- `go mod`: Administra dependencias y m√≥dulos en Go.
- `go mod tidy`: Limpia el archivo go.mod eliminando dependencias no usadas y agregando las necesarias.
- `go clean`: Limpia archivos de compilaci√≥n y cach√©.
- `go doc`: Muestra la documentaci√≥n de los paquetes y funciones.
- `go get`: Descarga, instala y actualiza paquetes desde repositorios remotos.
- `go tool pprof`: Genera perfiles de rendimiento para identificar cuellos de botella en tu c√≥digo.
- `go tool trace`: Genera registros de ejecuci√≥n detallados para analizar la ejecuci√≥n de tu programa.
- `godoc`: Un servidor web para explorar la documentaci√≥n de los paquetes de Go.
- `go work`: Administra m√∫ltiples m√≥dulos en un solo directorio de trabajo.
- `go env`: Muestra las variables de entorno de Go.
- `go version`: Muestra la versi√≥n del compilador de Go.
- `go list`: Lista los paquetes instalados.
- `go mod vendor`: Copia las dependencias a un directorio vendor en tu proyecto, lo que puede ayudar con la gesti√≥n de dependencias en entornos de construcci√≥n controlados.
- `go install ./...`: Instala todos los paquetes en el directorio actual y subdirectorios.
- `go run ./...`: Ejecuta todos los paquetes en el directorio actual y subdirectorios.
- `go debug (para Go 1.20+)`: Permite interactuar con un depurador para la ejecuci√≥n del programa en un entorno de desarrollo.
