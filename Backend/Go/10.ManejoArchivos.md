# 10. Manejo de Archivos en Go

El manejo de archivos en Go es sencillo y eficiente, gracias a su biblioteca estándar, que proporciona funciones para trabajar con archivos de texto y binarios.

## 10.1. Lectura y Escritura de Archivos

- ### Lectura de Archivos de Texto

  Para leer archivos de texto, Go proporciona funciones como `os.Open()` y `ioutil.ReadFile()`. Aquí se muestra cómo leer un archivo línea por línea o en su totalidad.

  ```go
  package main

  import (
      "fmt"
      "io/ioutil"
      "log"
  )

  func main() {
      content, err := ioutil.ReadFile("archivo.txt")
      if err != nil {
          log.Fatal(err)
      }
      fmt.Println(string(content))
  }

  ```

- ### Lectura Línea por Línea

  ```go
  package main

  import (
      "bufio"
      "fmt"
      "log"
      "os"
  )

  func main() {
      file, err := os.Open("archivo.txt")
      if err != nil {
          log.Fatal(err)
      }
      defer file.Close()

      scanner := bufio.NewScanner(file)
      for scanner.Scan() {
          fmt.Println(scanner.Text())
      }

      if err := scanner.Err(); err != nil {
          log.Fatal(err)
      }
  }

  ```

- ### Escritura de Archivos de Texto

  La escritura en archivos se realiza usando `os.Create()` o `os.OpenFile()` con permisos de escritura. Aquí se muestra cómo escribir en un archivo de texto:

  ```go
  package main

  import (
      "fmt"
      "os"
  )

  func main() {
      file, err := os.Create("nuevo_archivo.txt")
      if err != nil {
          fmt.Println(err)
          return
      }
      defer file.Close()

      _, err = file.WriteString("Hola, mundo!\n")
      if err != nil {
          fmt.Println(err)
          return
      }

      fmt.Println("Archivo escrito exitosamente.")
  }

  ```

---

## 10.2. Operaciones con Archivos

Go también proporciona funciones para realizar operaciones como abrir, cerrar, renombrar y eliminar archivos.

- ### Abrir y Cerrar Archivos

  - `os.Open()` abre un archivo en modo solo lectura.
  - `os.OpenFile()` abre un archivo en modo de lectura y escritura o crea uno si no existe.

    ```go
    file, err := os.Open("archivo.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer file.Close()

    ```

- ### Renombrar Archivos

  Para renombrar un archivo, se usa la función `os.Rename()`.

  ```go
  err := os.Rename("archivo_viejo.txt", "archivo_nuevo.txt")
  if err != nil {
      log.Fatal(err)
  }

  ```

- ### Eliminar Archivos

  La función `os.Remove()` permite eliminar archivos.

  ```go
  err := os.Remove("archivo.txt")
  if err != nil {
      log.Fatal(err)
  }

  ```

---

## 10.3. Buffers de Lectura y Escritura

Cuando se trabaja con archivos grandes, es más eficiente utilizar buffers de lectura y escritura. Esto ayuda a minimizar el uso de memoria y mejorar el rendimiento.

### Buffer de Lectura

Se puede usar `bufio.NewReader()` para leer archivos en bloques en lugar de cargar todo el archivo en memoria.

```go
package main

import (
    "bufio"
    "fmt"
    "log"
    "os"
)

func main() {
    file, err := os.Open("archivo_grande.txt")
    if err != nil {
        log.Fatal(err)
    }
    defer file.Close()

    reader := bufio.NewReader(file)
    buffer := make([]byte, 1024)
    for {
        bytesRead, err := reader.Read(buffer)
        if err != nil {
            break
        }
        fmt.Print(string(buffer[:bytesRead]))
    }
}

```

### Buffer de Escritura

Para escribir datos grandes en un archivo, se puede usar bufio.NewWriter() para escribir en pequeños fragmentos, mejorando la eficiencia.

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Create("archivo_salida.txt")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer file.Close()

    writer := bufio.NewWriter(file)
    for i := 0; i < 10; i++ {
        writer.WriteString(fmt.Sprintf("Línea %d\n", i))
    }
    writer.Flush() // Asegura que el contenido se escriba en el archivo
}

```

---

## 10.4. Serialización y Deserialización

La serialización y deserialización son técnicas para guardar y recuperar estructuras de datos complejas (como structs) en archivos. En Go, el paquete `encoding/json` y `encoding/gob` son comunes para este propósito.

- ### Serialización y Deserialización con JSON

  - **Serialización a JSON:**

    ```go
    package main

    import (
        "encoding/json"
        "fmt"
        "os"
    )

    type Persona struct {
        Nombre string
        Edad   int
    }

    func main() {
        p := Persona{"Kevin", 30}

        file, err := os.Create("persona.json")
        if err != nil {
            fmt.Println(err)
            return
        }
        defer file.Close()

        encoder := json.NewEncoder(file)
        err = encoder.Encode(p)
        if err != nil {
            fmt.Println(err)
        }
    }

    ```

  - **Deserialización desde JSON:**

    ```go
    package main

    import (
        "encoding/json"
        "fmt"
        "os"
    )

    type Persona struct {
        Nombre string
        Edad   int
    }

    func main() {
        file, err := os.Open("persona.json")
        if err != nil {
            fmt.Println(err)
            return
        }
        defer file.Close()

        var p Persona
        decoder := json.NewDecoder(file)
        err = decoder.Decode(&p)
        if err != nil {
            fmt.Println(err)
            return
        }

        fmt.Printf("Nombre: %s, Edad: %d\n", p.Nombre, p.Edad)
    }

    ```

- ### Serialización y Deserialización con GOB

  - **Serialización a GOB:**

    ```go
    package main

    import (
        "encoding/gob"
        "fmt"
        "os"
    )

    type Persona struct {
        Nombre string
        Edad   int
    }

    func main() {
        p := Persona{"Kevin", 30}

        file, err := os.Create("persona.gob")
        if err != nil {
            fmt.Println(err)
            return
        }
        defer file.Close()

        encoder := gob.NewEncoder(file)
        err = encoder.Encode(p)
        if err != nil {
            fmt.Println(err)
        }
    }

    ```

  - **Deserialización desde GOB:**

    ```go
    package main

    import (
        "encoding/gob"
        "fmt"
        "os"
    )

    type Persona struct {
        Nombre string
        Edad   int
    }

    func main() {
        file, err := os.Open("persona.gob")
        if err != nil {
            fmt.Println(err)
            return
        }
        defer file.Close()

        var p Persona
        decoder := gob.NewDecoder(file)
        err = decoder.Decode(&p)
        if err != nil {
            fmt.Println(err)
            return
        }

        fmt.Printf("Nombre: %s, Edad: %d\n", p.Nombre, p.Edad)
    }

    ```
